---
phase: 01-core-pipeline
plan: 03
type: execute
wave: 3
depends_on:
  - "01-02"
files_modified:
  - src/layout/elk-layout.ts
  - src/canvas/FgaGraph.tsx
autonomous: true
requirements:
  - VIZ-06
  - VIZ-07
  - CTRL-07
  - CTRL-08

must_haves:
  truths:
    - "Graph uses a 1-pass flat ELK layout with orthogonal edge routing (no compound hierarchy)"
    - "Layout supports TB and LR direction toggle via elk.direction DOWN/RIGHT"
    - "ELK ports map to card row Handle IDs with FIXED_ORDER constraint"
    - "Minimap is visible for graph overview"
    - "Controls panel provides zoom-in, zoom-out, and fit-view buttons"
    - "Cards render at correct positions after layout with no overlaps"
    - "Default model renders correctly in browser"
  artifacts:
    - path: "src/layout/elk-layout.ts"
      provides: "1-pass flat ELK layout with port-based orthogonal routing"
      exports: ["getLayoutedElements"]
    - path: "src/canvas/FgaGraph.tsx"
      provides: "React Flow orchestration with new node/edge types, minimap, controls"
  key_links:
    - from: "src/layout/elk-layout.ts"
      to: "src/canvas/fgaToFlow.ts"
      via: "consumes React Flow nodes with SchemaCard data to build ELK ports"
      pattern: "SchemaCard|CardRow|rows"
    - from: "src/canvas/FgaGraph.tsx"
      to: "src/canvas/nodes/TypeCardNode.tsx"
      via: "registered in nodeTypes map as typeCard"
      pattern: "typeCard.*TypeCardNode"
    - from: "src/canvas/FgaGraph.tsx"
      to: "src/canvas/edges/DimensionEdge.tsx"
      via: "registered in edgeTypes map as dimension"
      pattern: "dimension.*DimensionEdge"
    - from: "src/canvas/FgaGraph.tsx"
      to: "src/layout/elk-layout.ts"
      via: "calls getLayoutedElements after nodes initialized"
      pattern: "getLayoutedElements"
---

<objective>
Rewrite the ELK layout engine to a single-pass flat layout with orthogonal routing and port constraints, then wire the new pipeline into FgaGraph with MiniMap and Controls.

Purpose: The old 3-pass compound layout (hierarchical + grid redistribution + root repack) is replaced by a simpler 1-pass flat layout where each card is a top-level ELK node with ports matching its row Handles. This is the moment where the new pipeline becomes visually functional — cards render at computed positions with routed edges, plus MiniMap/Controls for navigation.

Output: Rewritten `elk-layout.ts` (1-pass flat), rewritten `FgaGraph.tsx` (new node/edge types, MiniMap, Controls).
</objective>

<execution_context>
@/Users/thedoc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thedoc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-pipeline/01-RESEARCH.md
@.planning/phases/01-core-pipeline/01-CONTEXT.md
@.planning/phases/01-core-pipeline/01-01-SUMMARY.md
@.planning/phases/01-core-pipeline/01-02-SUMMARY.md

@src/layout/elk-layout.ts
@src/layout/elk-path.ts
@src/canvas/FgaGraph.tsx
@src/canvas/fgaToFlow.ts
@src/canvas/nodes/TypeCardNode.tsx
@src/canvas/edges/DimensionEdge.tsx
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite ELK layout to 1-pass flat with ports</name>
  <files>src/layout/elk-layout.ts</files>
  <action>
Complete rewrite of `src/layout/elk-layout.ts`. Delete all existing code (3-pass compound pipeline, grid redistribution, root repack). Replace with a single-pass flat ELK layout.

**Public API (unchanged signature):**
```typescript
export async function getLayoutedElements(
  nodes: Node[],
  edges: Edge[],
  direction: LayoutDirection,
): Promise<{ nodes: Node[]; edges: Edge[] }>
```

**ELK graph construction:**

For each React Flow node (each is a TypeCardNode with `SchemaCard` data):
1. Read `node.measured.width` and `node.measured.height` (React Flow measures these after initial render)
2. Build ports array from `data.rows`:
   - Iterate rows in order (bindings, relations, permissions — already sorted by fgaToFlow)
   - For each row, create TWO ports:
     - Target port: `{ id: '{row.id}__target', properties: { 'port.side': direction === 'TB' ? 'WEST' : 'NORTH', 'port.index': targetIndex++ } }`
     - Source port: `{ id: '{row.id}__source', properties: { 'port.side': direction === 'TB' ? 'EAST' : 'SOUTH', 'port.index': sourceIndex++ } }`
   - Also add header ports: `{nodeId}__header_target` and `{nodeId}__header_source`
3. Build ELK node:
   ```
   { id: node.id, width: measured.width ?? 280, height: measured.height ?? 100,
     properties: { 'org.eclipse.elk.portConstraints': 'FIXED_ORDER' },
     ports: [...ports] }
   ```

For each React Flow edge:
1. Build ELK edge with port references:
   ```
   { id: edge.id, sources: [edge.sourceHandle ?? edge.source], targets: [edge.targetHandle ?? edge.target] }
   ```

**ELK layout options (flat, no hierarchy):**
```
'elk.algorithm': 'layered'
'elk.direction': direction === 'TB' ? 'DOWN' : 'RIGHT'
'elk.edgeRouting': 'ORTHOGONAL'
'elk.spacing.nodeNode': '50'
'elk.layered.spacing.nodeNodeBetweenLayers': '70'
'elk.spacing.portPort': '4'
'elk.layered.nodePlacement.strategy': 'NETWORK_SIMPLEX'
'elk.layered.nodePlacement.favorStraightEdges': 'true'
'elk.layered.crossingMinimization.strategy': 'LAYER_SWEEP'
```

No `hierarchyHandling`, no `INCLUDE_CHILDREN` — flat graph, every card is a root-level node.

**After layout:**
1. Map ELK node positions back to React Flow nodes: `node.position = { x: elkNode.x, y: elkNode.y }`
2. For edges: extract ELK edge sections (bend points) and attach as `elkRoute` data:
   - Each ELK edge has `sections` array. Each section has `startPoint`, `endPoint`, and optionally `bendPoints`
   - Collect all points into a single `points: Point[]` array for each edge
   - Attach as `edge.data = { ...edge.data, elkRoute: { points } }`

**LRU cache:** Keep the caching pattern but with a new cache key format:
- Key: `${direction}|${sortedNodeDimensions}|${sortedEdgeIds}` where `sortedNodeDimensions` = sorted `"nodeId:w:h"` entries
- Cache size: 5 entries (same as before)

**Import:** Use `elk.bundled.js` directly on the main thread — do NOT wrap in a custom Web Worker (documented in CLAUDE.md gotchas). Import as: `import ELK from 'elkjs/lib/elk.bundled.js';`

**Keep `src/layout/elk-path.ts` unchanged** — its utilities (`elkPointsToPath`, `trimPathToHandles`, etc.) are still used by DimensionEdge.
  </action>
  <verify>
`npx tsc --noEmit -- src/layout/elk-layout.ts` compiles. `getLayoutedElements` is exported with correct signature. No references to `INCLUDE_CHILDREN`, grid redistribution, or root repack remain. ELK options include `ORTHOGONAL` routing and `FIXED_ORDER` port constraints.
  </verify>
  <done>
ELK layout is a single-pass flat algorithm with orthogonal routing and port constraints matching card row Handles. Cache key uses node dimensions and edge IDs. No compound hierarchy. Direction toggles between DOWN and RIGHT. Edge routes extracted from ELK sections and attached as elkRoute data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite FgaGraph with new pipeline, MiniMap, and Controls</name>
  <files>src/canvas/FgaGraph.tsx</files>
  <action>
Rewrite `src/canvas/FgaGraph.tsx` to wire the new pipeline components and add MiniMap + Controls.

**Node and edge type registrations:**
```typescript
import { TypeCardNode } from './nodes/TypeCardNode';
import { DimensionEdge } from './edges/DimensionEdge';

const nodeTypes = { typeCard: TypeCardNode };
const edgeTypes = { dimension: DimensionEdge };
```

Remove all imports of old components: `TypeNode`, `RelationNode`, `PermissionNode`, `DirectEdge`, `ComputedEdge`, `TuplesetDepEdge`.

**Add MiniMap and Controls imports:**
```typescript
import { MiniMap, Controls } from '@xyflow/react';
```

**Flow conversion:**
The `toFlowElements` call changes — it now takes the full `AuthorizationGraph` and returns `{ nodes, edges, dimensions }`:
```typescript
const { nodes: visibleNodes, edges: visibleEdges } = useViewerStore(
  useShallow((s) => s.getVisibleGraph()),
);
const { nodes: flowNodes, edges: flowEdges } = useMemo(
  () => toFlowElements({ nodes: visibleNodes, edges: visibleEdges }),
  [visibleNodes, visibleEdges],
);
```

Note: `toFlowElements` now takes `AuthorizationGraph` as a single argument (not separate nodes/edges). Adjust the call accordingly. The `dimensions` return value can be ignored here — the store will hold dimensions separately (Plan 04).

**Layout orchestration:**
Keep the same render-measure-layout pattern:
1. Set initial nodes/edges at position {0,0} (fgaToFlow already does this)
2. Wait for `useNodesInitialized()` to be true
3. Call `getLayoutedElements(nodesRef.current, edgesRef.current, layoutDirection)`
4. Apply positioned nodes/edges
5. Fade in via `layoutReady` opacity pattern
6. `fitView` with padding after layout

Keep all existing patterns: `layoutDone` ref, `prevParseVersion` ref, `cancelled` flag, `nodesRef`/`edgesRef`, `onNodeDragStart` (strip elkRoute).

**Simplify hover handlers:**
- Remove the compound node guard from `onNodeMouseEnter` (no more compound nodes):
  ```typescript
  const onNodeMouseEnter = useCallback(
    (_: React.MouseEvent, node: Node) => {
      setHoveredNode(node.id, fullEdges);
    },
    [setHoveredNode, fullEdges],
  );
  ```
  Note: This will still call the old hover store API for now. Plan 04 rewrites the hover store to row-level granularity. For this plan, keep the existing hover store interface so the app doesn't crash.

**MiniMap and Controls placement:**
Inside the `<ReactFlow>` component, add as children:
```tsx
<MiniMap
  style={{ background: 'rgba(15, 23, 42, 0.9)' }}
  maskColor="rgba(15, 23, 42, 0.7)"
  nodeColor={() => '#334155'}
  pannable
  zoomable
/>
<Controls
  style={{ background: 'rgba(15, 23, 42, 0.9)', border: '1px solid #2a3a5c' }}
  showInteractive={false}
/>
```

Style the controls to match the dark glass theme. Use `showInteractive={false}` to hide the interactive toggle (not needed for this visualization tool).

**fitView defaults:**
Update `fitView` to start at a readable zoom level per locked decision ("readable zoom as default"):
```typescript
reactFlow.fitView({ duration: 200, minZoom: 0.5, maxZoom: 1.2, padding: 0.08 });
```
Use `minZoom: 0.5` and `maxZoom: 1.2` to ensure text is readable by default. The `padding: 0.08` provides moderate breathing room.

**Remove Breadcrumb import** if it exists — breadcrumb navigation belongs to Phase 2 subgraph exploration.
  </action>
  <verify>
`npm run build` succeeds (this is the first point where the full new pipeline should compile and render). Load the app in a browser — the sample model should display as ERD cards with edges. MiniMap and Controls should be visible. Verify no console errors.
  </verify>
  <done>
FgaGraph registers TypeCardNode and DimensionEdge as the sole node/edge types. MiniMap and Controls are rendered with dark theme styling. Layout uses 1-pass flat ELK. Cards appear at computed positions with orthogonal edges. App compiles and renders the sample model.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes (the new pipeline is fully wired)
2. Opening the app shows ERD schema cards for the sample model
3. Cards are positioned by ELK with orthogonal edge routing
4. Switching layout direction (TB/LR) repositions cards correctly
5. MiniMap renders in bottom-left corner with dark styling
6. Controls panel renders with zoom and fit-view buttons
7. Cards don't overlap — ELK spacing produces readable layout
8. Edges route between correct row handles (verify arrowheads point to correct rows)
</verification>

<success_criteria>
- 1-pass flat ELK layout positions all cards without overlaps
- Orthogonal edge routing produces clean right-angle paths between card handles
- TB and LR directions both produce correct layouts with proper port side assignment
- MiniMap provides graph overview navigation
- Controls panel provides zoom-in, zoom-out, and fit-view
- App loads the sample model and renders it as ERD cards on first visit
- No console errors during normal operation
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-pipeline/01-03-SUMMARY.md`
</output>
