---
phase: 02-interaction-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/store/viewer-store.ts
  - src/types.ts
  - src/graph/traversal.ts
autonomous: true
requirements: [INT-03, INT-04, INT-05, INT-06, PATH-03]

must_haves:
  truths:
    - "Navigation stack stores subgraph frames with entry node, direction, visible type IDs, and relevant row IDs"
    - "navigateToSubgraph() computes correct upstream/downstream node sets using existing BFS functions"
    - "popSubgraph() removes the top frame and restores the previous subgraph state"
    - "jumpToLevel() can jump to any level in the navigation stack (including 0 for full graph)"
    - "collapsedCards set tracks which type cards are collapsed to header-only"
    - "Self-referencing dimensions are detected and stored for downstream rendering"
    - "Browser history pushState is called on drill-in, popstate handler pops navigation stack"
  artifacts:
    - path: "src/types.ts"
      provides: "NavigationFrame interface and SelfReferencingDimension type"
      contains: "NavigationFrame"
    - path: "src/store/viewer-store.ts"
      provides: "Navigation stack state, collapsed cards, dimmed rows toggle, recently visited, navigation actions"
      contains: "navigationStack"
    - path: "src/graph/traversal.ts"
      provides: "Self-referencing dimension detection function"
      contains: "detectSelfReferencing"
  key_links:
    - from: "src/store/viewer-store.ts"
      to: "src/graph/traversal.ts"
      via: "traceUpstream/traceDownstream import for subgraph computation"
      pattern: "traceUpstream|traceDownstream"
    - from: "src/store/viewer-store.ts"
      to: "src/types.ts"
      via: "NavigationFrame type import"
      pattern: "NavigationFrame"
---

<objective>
Build the navigation stack state machine in the Zustand store with all subgraph computation logic, card collapse state, and browser history integration. This is the data/logic layer that the UI plans (02-03, 02-04) will consume.

Purpose: Separates state management from UI rendering. The store computes subgraph node sets using existing BFS functions and exposes them via stable references for efficient component subscriptions.

Output: Extended ViewerStore with navigation stack, collapse state, and browser history integration. NavigationFrame type definition. Self-referencing dimension detection.
</objective>

<execution_context>
@/Users/thedoc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thedoc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-interaction-polish/02-CONTEXT.md
@.planning/phases/02-interaction-polish/02-RESEARCH.md

@src/store/viewer-store.ts
@src/store/hover-store.ts
@src/types.ts
@src/graph/traversal.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: NavigationFrame type and self-referencing dimension detection</name>
  <files>
    src/types.ts
    src/graph/traversal.ts
  </files>
  <action>
    **Types (src/types.ts):**
    Add a `NavigationFrame` interface:
    ```typescript
    /** A single frame in the subgraph navigation stack */
    export interface NavigationFrame {
      /** The node ID that was clicked to enter this subgraph */
      entryNodeId: string;
      /** Direction of traversal */
      direction: 'upstream' | 'downstream';
      /** Display label for breadcrumb (e.g., "document#can_view" or "user") */
      label: string;
      /** Type names of cards visible in this subgraph */
      visibleTypeIds: Set<string>;
      /** Row IDs (AuthorizationNode IDs) that are "relevant" (non-dimmed) */
      relevantRowIds: Set<string>;
    }
    ```

    Add a `SelfReferencingDimension` interface:
    ```typescript
    /** A dimension that references itself (e.g., parent category hierarchy) */
    export interface SelfReferencingDimension {
      /** Dimension name */
      dimensionName: string;
      /** The type that self-references */
      typeName: string;
      /** Tooltip text explaining the self-reference */
      tooltip: string;
    }
    ```

    **Self-referencing dimension detection (src/graph/traversal.ts):**
    Add a `detectSelfReferencingDimensions` function:
    ```typescript
    /**
     * Detect dimensions where a type references itself via a TTU edge.
     * e.g., category#parent -> category (parent category hierarchy).
     * Returns an array of SelfReferencingDimension objects.
     */
    export function detectSelfReferencingDimensions(
      edges: AuthorizationEdge[],
    ): SelfReferencingDimension[]
    ```
    Logic:
    - Filter edges to `rewriteRule === "ttu"`.
    - For each TTU edge, extract source type and target type (split on `#`).
    - If source type === target type, this is self-referencing.
    - Group by `tuplesetRelation` (dimension name) + type name.
    - Generate tooltip: `"Permission can be inherited from parent ${dimensionName}s"` or similar descriptive text.
    - Import `SelfReferencingDimension` type from `../types` using `import type`.
  </action>
  <verify>
    Run `npm run build` -- must compile without errors.
    Run `npm run lint` -- must pass.
  </verify>
  <done>
    NavigationFrame and SelfReferencingDimension types defined. detectSelfReferencingDimensions function correctly identifies self-referencing TTU patterns. Build and lint pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Navigation stack store, collapse state, and browser history integration</name>
  <files>
    src/store/viewer-store.ts
  </files>
  <action>
    **Extend ViewerStore interface with new state fields:**
    ```typescript
    // Navigation
    navigationStack: NavigationFrame[];
    collapsedCards: Set<string>;       // type names of collapsed cards
    dimmedRowsHidden: boolean;         // toggle to hide irrelevant rows in subgraph
    recentlyVisited: string[];         // last 5 node IDs for command palette
    selfReferencingDimensions: SelfReferencingDimension[];

    // Navigation actions
    navigateToSubgraph: (nodeId: string, direction: 'upstream' | 'downstream') => void;
    popSubgraph: () => void;
    jumpToLevel: (index: number) => void;

    // Card collapse
    toggleCardCollapse: (typeName: string) => void;

    // Dimmed rows toggle
    toggleDimmedRowsHidden: () => void;
    ```

    **Import `NavigationFrame` and `SelfReferencingDimension` from `../types` using `import type`.**
    **Import `traceUpstream`, `traceDownstream`, `detectSelfReferencingDimensions` from `../graph/traversal`.**

    **Initial state values:**
    - `navigationStack: []`
    - `collapsedCards: new Set()`
    - `dimmedRowsHidden: false`
    - `recentlyVisited: []`
    - `selfReferencingDimensions: []`

    **Compute self-referencing dimensions in `parse()` action:**
    - After building the graph, call `detectSelfReferencingDimensions(edges)`.
    - Store result in `selfReferencingDimensions`.
    - Also reset `navigationStack: []`, `collapsedCards: new Set()` on re-parse.

    **`navigateToSubgraph(nodeId, direction)` action:**
    - Wrap in `startTransition`.
    - Compute subgraph based on direction:
      - `'upstream'`: call `traceUpstream(nodeId, get().edges)` to get `{ nodeIds, rowIds }`.
      - `'downstream'`: call `traceDownstream(nodeId, get().nodes, get().edges)` to get `{ nodeIds, rowIds }`.
    - Extract visible type IDs from nodeIds: for each nodeId, `nodeId.split('#')[0]` gives the type name. Collect into a `Set<string>`.
    - Build the NavigationFrame with: `entryNodeId: nodeId`, `direction`, `label: nodeId` (the full ID like "document#can_view"), `visibleTypeIds`, `relevantRowIds: rowIds`.
    - Push frame onto `navigationStack`.
    - Update `recentlyVisited`: prepend `nodeId`, deduplicate, keep last 5.
    - Call `window.history.pushState({ stackDepth: newStack.length }, '')`.
    - **Do NOT call `history.pushState` from within the `popstate` handler** (see anti-pattern in research).

    **`popSubgraph()` action:**
    - Wrap in `startTransition`.
    - If `navigationStack.length === 0`, return (already at overview).
    - Pop the last frame from `navigationStack`.
    - Set the updated stack.
    - Do NOT call `history.back()` or `history.pushState` -- this action is called BY the popstate handler.

    **`jumpToLevel(index)` action:**
    - Wrap in `startTransition`.
    - If `index <= 0`: set `navigationStack: []` (return to full overview).
    - If `index >= navigationStack.length`: return (no change).
    - Otherwise: slice stack to `navigationStack.slice(0, index)`.
    - Do NOT manipulate browser history here -- the caller (breadcrumb click or popstate) handles it.

    **`toggleCardCollapse(typeName)` action:**
    - Create a new `Set` from `collapsedCards`.
    - If `typeName` is in the set, delete it; otherwise add it.
    - `set({ collapsedCards: newSet })`.

    **`toggleDimmedRowsHidden()` action:**
    - `set((s) => ({ dimmedRowsHidden: !s.dimmedRowsHidden }))`.

    **Browser history popstate handler:**
    - This will be wired in FgaGraph.tsx or App.tsx (Plan 02-04), NOT in the store.
    - The store just provides `jumpToLevel()` which the handler calls.

    **Zustand re-render considerations (CRITICAL):**
    - `navigationStack` is an array -- changing it creates a new reference. Components should NOT subscribe to the whole array.
    - Instead, expose derived selectors that components can use:
      - `s.navigationStack.length` (primitive)
      - `s.navigationStack[s.navigationStack.length - 1]` (last frame)
    - The `visibleTypeIds` and `relevantRowIds` Sets inside frames are stable references (created once per navigation action).
    - `collapsedCards` is a Set -- changing it creates a new Set reference. This is fine because collapse is infrequent.
  </action>
  <verify>
    Run `npm run build` -- must compile without errors.
    Run `npm run lint` -- must pass.
    Verify: `navigateToSubgraph`, `popSubgraph`, `jumpToLevel`, `toggleCardCollapse`, `toggleDimmedRowsHidden` are all defined as actions in the store.
  </verify>
  <done>
    ViewerStore extended with navigation stack, collapsed cards, dimmed rows toggle, recently visited tracking, and self-referencing dimensions. Navigation actions correctly compute subgraph node sets using existing BFS. Browser history pushState called on drill-in. Build and lint pass clean.
  </done>
</task>

</tasks>

<verification>
- `npm run build` passes with zero errors
- `npm run lint` passes clean
- `NavigationFrame` interface exists in `src/types.ts`
- `detectSelfReferencingDimensions` function exists in `src/graph/traversal.ts`
- ViewerStore has `navigationStack`, `collapsedCards`, `dimmedRowsHidden`, `recentlyVisited`, `selfReferencingDimensions`
- Store actions `navigateToSubgraph`, `popSubgraph`, `jumpToLevel`, `toggleCardCollapse`, `toggleDimmedRowsHidden` are implemented
- `parse()` resets navigation state and computes self-referencing dimensions
</verification>

<success_criteria>
1. NavigationFrame type captures entry node, direction, label, visible type IDs, and relevant row IDs
2. navigateToSubgraph correctly uses traceUpstream/traceDownstream to compute subgraph scope
3. Browser history integration pushes state on drill-in
4. Card collapse state tracks collapsed type names
5. Self-referencing dimensions detected from TTU edge patterns
6. Recently visited list maintained (last 5, deduplicated)
7. Build and lint pass clean
</success_criteria>

<output>
After completion, create `.planning/phases/02-interaction-polish/02-02-SUMMARY.md`
</output>
