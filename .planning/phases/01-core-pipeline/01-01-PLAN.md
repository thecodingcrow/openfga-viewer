---
phase: 01-core-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/dimensions/detect.ts
  - src/theme/dimensions.ts
  - src/theme/colors.ts
autonomous: true
requirements:
  - DATA-01
  - DATA-02
  - DATA-03
  - VIZ-04
  - VIZ-05

must_haves:
  truths:
    - "Dimensions are auto-detected from TTU tupleset patterns in the parsed AuthorizationGraph"
    - "Every edge is classified as either type-restriction (direct) or dimension (ttu)"
    - "Same-card edges (computed, tupleset-dep) are identified for exclusion from visual edges"
    - "Each dimension gets a unique colorblind-safe color from Paul Tol Muted palette"
    - "Type restriction edges get a distinct muted slate color"
    - "Expression definitions transform X from Y into dimension-annotated notation"
  artifacts:
    - path: "src/dimensions/detect.ts"
      provides: "Dimension detection and edge classification"
      exports: ["detectDimensions", "classifyEdges", "transformExpression"]
    - path: "src/theme/dimensions.ts"
      provides: "Colorblind-safe dimension palette and color assignment"
      exports: ["DIMENSION_PALETTE", "TYPE_RESTRICTION_COLOR", "assignDimensionColors"]
    - path: "src/types.ts"
      provides: "Dimension and SchemaCard type definitions"
      contains: "interface Dimension"
    - path: "src/theme/colors.ts"
      provides: "Updated theme without old edge-specific colors"
  key_links:
    - from: "src/dimensions/detect.ts"
      to: "src/types.ts"
      via: "imports AuthorizationGraph, Dimension types"
      pattern: "import type.*Dimension.*from.*types"
    - from: "src/theme/dimensions.ts"
      to: "src/dimensions/detect.ts"
      via: "palette consumed by dimension color assignment"
      pattern: "DIMENSION_PALETTE"
---

<objective>
Build the pure data layer for the new visualization pipeline: dimension detection from the existing parsed AuthorizationGraph, edge classification (type-restriction vs dimension), expression transformation for display, and a colorblind-safe categorical palette.

Purpose: All downstream plans (card rendering, edge coloring, hover highlighting) depend on knowing which dimensions exist, which color each dimension gets, and how expressions display. This data layer has zero UI -- it operates on the parser's output and produces typed data structures.

Output: Four files -- updated `types.ts` with new interfaces, `dimensions/detect.ts` with detection + classification + expression transform, `theme/dimensions.ts` with palette + color assignment, updated `theme/colors.ts` with old edge colors removed.
</objective>

<execution_context>
@/Users/thedoc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thedoc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-pipeline/01-RESEARCH.md
@.planning/phases/01-core-pipeline/01-CONTEXT.md

@src/types.ts
@src/theme/colors.ts
@src/parser/parse-model.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dimension types and create dimension detection module</name>
  <files>src/types.ts, src/dimensions/detect.ts</files>
  <action>
**In `src/types.ts`**, add these new types (append after existing types, do NOT modify existing types):

```typescript
/** A structural dimension detected from TTU tupleset patterns */
export interface Dimension {
  /** Dimension name — the tupleset relation name (e.g., "client", "parent") */
  name: string;
  /** Assigned color from the dimension palette */
  color: string;
  /** AuthorizationNode IDs of bindings that create this dimension */
  bindingNodeIds: Set<string>;
  /** AuthorizationEdge IDs of TTU edges belonging to this dimension */
  edgeIds: Set<string>;
}

/** Classification of a visual edge */
export type EdgeClassification = 'type-restriction' | 'dimension';

/** A row in an ERD schema card */
export interface CardRow {
  /** Node ID — e.g., "client#admin" — matches AuthorizationNode.id */
  id: string;
  /** Display name — e.g., "admin" */
  name: string;
  /** Which section this row belongs to */
  section: 'binding' | 'relation' | 'permission';
  /** Transformed expression for display (permissions only) */
  expression?: string;
  /** Dimension color for binding dots (bindings only) */
  dimensionColor?: string;
}

/** Data for a single ERD schema card (one per FGA type) */
export interface SchemaCard {
  /** FGA type name — e.g., "client" */
  typeName: string;
  /** Type accent color for the header bar */
  accentColor: string;
  /** All rows in display order: bindings, then relations, then permissions */
  rows: CardRow[];
}
```

**Create `src/dimensions/detect.ts`** with three exported functions:

1. `detectDimensions(graph: AuthorizationGraph): Map<string, Dimension>` — iterate `graph.edges`, filter for `rewriteRule === 'ttu'`, group by `tuplesetRelation`. For each group create a `Dimension` with name = tuplesetRelation, empty color (assigned later), edgeIds = set of matching edge IDs. Then iterate `graph.nodes`, for nodes with `isTuplesetBinding === true`, find matching dimension by node's `relation` field, add node.id to `bindingNodeIds`. Return the Map keyed by dimension name.

2. `classifyEdges(edges: AuthorizationEdge[]): { crossCard: AuthorizationEdge[]; sameCard: AuthorizationEdge[] }` — cross-card edges are those with `rewriteRule === 'direct'` or `rewriteRule === 'ttu'`. Same-card edges are `rewriteRule === 'computed'` or `rewriteRule === 'tupleset-dep'`. Return both arrays. This implements DATA-02 (classification) and DATA-03 (same-card exclusion).

3. `transformExpression(definition: string): string` — transform the parser's definition string for display:
   - Split on ` or ` -> join with ` | `
   - Split on ` and ` -> join with ` & `
   - Split on ` but not ` -> join with ` \\ `
   - For each term: if matches pattern `{relation} from {type}`, transform to `↗{type}.{relation}`
   - `[type]` and `[type#relation]` patterns stay as-is (direct type restrictions)
   - Plain names stay as-is (computed references)
   - Handle nested/complex expressions by processing terms individually after operator split

Use `import type` for all type-only imports per `verbatimModuleSyntax` convention.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors. Verify `src/dimensions/detect.ts` exports all three functions. Verify `src/types.ts` exports the new interfaces/types.
  </verify>
  <done>
`detectDimensions()` correctly groups TTU edges by tuplesetRelation and collects binding nodes. `classifyEdges()` splits edges into cross-card and same-card arrays. `transformExpression()` converts definition strings with `↗` dimension notation and symbolic operators. All new types exported from `types.ts`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dimension palette and update theme colors</name>
  <files>src/theme/dimensions.ts, src/theme/colors.ts</files>
  <action>
**Create `src/theme/dimensions.ts`** with:

1. `DIMENSION_PALETTE` — Paul Tol's Muted qualitative palette, 9 hex colors as a `readonly string[]`:
   ```
   '#CC6677' (rose), '#332288' (indigo), '#DDCC77' (sand), '#117733' (green),
   '#88CCEE' (cyan), '#882255' (wine), '#44AA99' (teal), '#999933' (olive), '#AA4499' (purple)
   ```

2. `TYPE_RESTRICTION_COLOR = '#475569'` — slate-600, muted achromatic for direct type restriction edges (VIZ-05).

3. `assignDimensionColors(dimensions: Map<string, Dimension>): Map<string, Dimension>` — sort dimension names alphabetically for stable assignment. Assign colors from `DIMENSION_PALETTE` for first 9 dimensions. For dimensions 10+, generate via OKLCH: `oklch(0.7 0.15 ${hue})` where hue uses golden angle distribution `(i * 137.5) % 360`. Returns a NEW Map with color field populated (do not mutate input). Import `Dimension` type from `../types` using `import type`.

**Update `src/theme/colors.ts`**:
- Remove `edgeDirect`, `edgeComputed`, `edgeTuplesetDep` properties from the `blueprint` object (these are the old per-edge-type colors that no longer apply).
- Keep all other `blueprint` properties unchanged (bg, surface, accent, text colors, etc.).
- Keep `TYPE_PALETTE`, `EXTRA_COLORS`, `getTypeColor()` — these are still used for card accent bars.
- Add a re-export: `export { DIMENSION_PALETTE, TYPE_RESTRICTION_COLOR, assignDimensionColors } from './dimensions';` for convenient single-import access.

Note: The old `edgeDirect`, `edgeComputed`, `edgeTuplesetDep` colors are referenced in `fgaToFlow.ts` and `useEdgeInteraction.ts` — those files will be rewritten in Plan 02, so breaking their imports here is expected and acceptable.
  </action>
  <verify>
Run `npx tsc --noEmit -- src/theme/dimensions.ts src/theme/colors.ts src/types.ts src/dimensions/detect.ts` to verify just the new/updated files compile. Full project `tsc` may show errors in old files referencing removed `blueprint` properties — that is expected.
  </verify>
  <done>
Paul Tol Muted palette hardcoded with 9 colorblind-safe colors. OKLCH fallback generates distinct hues for >9 dimensions. `TYPE_RESTRICTION_COLOR` provides muted slate for type-restriction edges. Old edge-specific colors removed from `blueprint`. New palette re-exported from `colors.ts` for downstream consumers.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -- src/types.ts src/dimensions/detect.ts src/theme/dimensions.ts src/theme/colors.ts` compiles without errors
2. New exports are importable: `Dimension`, `SchemaCard`, `CardRow`, `EdgeClassification` from `types.ts`; `detectDimensions`, `classifyEdges`, `transformExpression` from `dimensions/detect.ts`; `DIMENSION_PALETTE`, `TYPE_RESTRICTION_COLOR`, `assignDimensionColors` from `theme/dimensions.ts`
3. `DIMENSION_PALETTE` has exactly 9 entries
4. `TYPE_RESTRICTION_COLOR` is `'#475569'`
</verification>

<success_criteria>
- Dimension detection produces correct dimensions for the sample model (at minimum: `client`, `parent`, `category`, `intellectual_property`, `ip_agency` dimensions)
- Edge classification splits edges into cross-card (direct + ttu) and same-card (computed + tupleset-dep)
- Expression transform converts `"can_read from client or member from ip_agency"` to `"↗client.can_read | ↗ip_agency.member"`
- Palette assigns unique colors to each dimension, stable across re-renders (alphabetical sort)
- No new runtime dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-pipeline/01-01-SUMMARY.md`
</output>
