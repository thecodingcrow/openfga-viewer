---
phase: 02-interaction-polish
plan: 04
type: execute
wave: 2
depends_on: [02-01, 02-02]
files_modified:
  - src/canvas/Breadcrumb.tsx
  - src/App.tsx
autonomous: true
requirements: [INT-05]

must_haves:
  truths:
    - "Breadcrumb trail appears in bottom-left corner when navigation stack is non-empty"
    - "Each breadcrumb segment is clickable to jump back to that level"
    - "First segment is 'Overview' (jumps to full graph)"
    - "Current (deepest) segment is highlighted in accent color"
    - "Esc key pops one level of the navigation stack"
    - "Browser back button pops one level via popstate handler"
    - "Breadcrumb disappears when at overview level (empty stack)"
  artifacts:
    - path: "src/canvas/Breadcrumb.tsx"
      provides: "Breadcrumb trail component for subgraph navigation"
      contains: "Breadcrumb"
    - path: "src/App.tsx"
      provides: "Esc key handler for navigation pop, popstate handler for browser back"
  key_links:
    - from: "src/canvas/Breadcrumb.tsx"
      to: "src/store/viewer-store.ts"
      via: "navigationStack and jumpToLevel subscriptions"
      pattern: "navigationStack|jumpToLevel"
    - from: "src/App.tsx"
      to: "src/store/viewer-store.ts"
      via: "popSubgraph on Esc, jumpToLevel on popstate"
      pattern: "popSubgraph|jumpToLevel"
---

<objective>
Implement the breadcrumb trail for subgraph navigation and wire Esc key + browser back button to pop the navigation stack.

Purpose: Users need visual feedback about their navigation depth and easy ways to go back. The breadcrumb provides context (where am I?), Esc provides keyboard navigation, and browser back provides familiar browser-native navigation.

Output: Breadcrumb component rendered in bottom-left, Esc key pops one level, browser back button pops via popstate.
</objective>

<execution_context>
@/Users/thedoc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thedoc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-interaction-polish/02-CONTEXT.md
@.planning/phases/02-interaction-polish/02-RESEARCH.md
@.planning/phases/02-interaction-polish/02-01-SUMMARY.md
@.planning/phases/02-interaction-polish/02-02-SUMMARY.md

@src/App.tsx
@src/canvas/FgaGraph.tsx
@src/store/viewer-store.ts
@src/theme/colors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Breadcrumb component</name>
  <files>
    src/canvas/Breadcrumb.tsx
  </files>
  <action>
    **Create `src/canvas/Breadcrumb.tsx`:**
    - This is a new file.
    - Default export: `Breadcrumb` component.
    - Subscribe to `navigationStack` from viewer-store: use `useViewerStore((s) => s.navigationStack)` for the array reference and `useViewerStore((s) => s.jumpToLevel)` for the action.
    - If `navigationStack.length === 0`, return `null` (no breadcrumb at overview).

    **Rendering:**
    ```
    Position: absolute bottom-4 left-3 z-40
    Layout: flex items-center gap-1 text-xs
    ```

    - First segment: "Overview" button that calls `jumpToLevel(0)`.
      - Also calls `window.history.go(-(navigationStack.length))` to sync browser history back to the beginning.
    - For each frame in `navigationStack`: render a separator `/` and a button with the frame's `label`.
      - Each button calls `jumpToLevel(i + 1)` where `i` is the frame index.
      - Also calls `window.history.go(-(navigationStack.length - (i + 1)))` to sync browser history.
    - Style active (last) segment in `blueprint.accent` color.
    - Style inactive segments in `blueprint.muted` color.
    - Each button gets: `hud-panel px-2 py-1 rounded-md cursor-pointer` classes.
    - Separator `/` styled in `blueprint.muted`.

    **Important:**
    - Use `Fragment` from React for the separator + button pairs (import `Fragment`).
    - Use `useCallback` for click handlers. Since the number of segments is dynamic, use inline arrow functions in the map but wrap the overall handler factory in `useCallback` if possible. Given that breadcrumb clicks are infrequent, inline handlers in the map are acceptable here.
    - Import `blueprint` from `../theme/colors`.
    - Use `import type` for any type-only imports.
  </action>
  <verify>
    Run `npm run build` -- must compile without errors.
    Run `npm run lint` -- must pass.
  </verify>
  <done>
    Breadcrumb component renders navigation trail in bottom-left corner. Each segment is clickable. Overview button returns to full graph. Current level highlighted in accent color. Component returns null when at overview level.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Breadcrumb into App, Esc key navigation pop, and browser popstate handler</name>
  <files>
    src/App.tsx
  </files>
  <action>
    **Add Breadcrumb to layout (src/App.tsx):**
    - Import `Breadcrumb` from `./canvas/Breadcrumb`.
    - Render `<Breadcrumb />` inside the canvas area (as a sibling to `<Canvas />` and `<Toolbar />`, within the relative-positioned container).

    **Esc key handling:**
    - The existing `handleKeyDown` in App.tsx handles Esc to close search.
    - Extend: if search is not open AND `navigationStack.length > 0`, call `popSubgraph()` and `window.history.back()`.
    - Subscribe to `popSubgraph` from viewer-store: `const popSubgraph = useViewerStore((s) => s.popSubgraph);`.
    - Subscribe to `navigationStack.length` for the condition check: `const navDepth = useViewerStore((s) => s.navigationStack.length);`.
    - Priority order for Esc: (1) close search if open, (2) pop subgraph if navigated, (3) do nothing.

    **Browser popstate handler:**
    - Add a `useEffect` that listens for `popstate` events on `window`.
    - On `popstate`:
      ```typescript
      const handlePopState = (e: PopStateEvent) => {
        const targetDepth = (e.state as { stackDepth?: number })?.stackDepth ?? 0;
        const currentDepth = useViewerStore.getState().navigationStack.length;
        if (targetDepth < currentDepth) {
          useViewerStore.getState().jumpToLevel(targetDepth);
        }
      };
      ```
    - **Critical:** Do NOT call `history.pushState`, `history.back()`, or `history.forward()` from within the `popstate` handler. This prevents the circular loop pitfall described in the research.
    - The `popstate` handler reads directly from `useViewerStore.getState()` (not from subscriptions) to avoid stale closures.
    - Cleanup: remove the event listener on unmount.

    **Important constraints:**
    - Do NOT use React Router. Raw History API is sufficient.
    - The `popstate` handler must be stable (no dependency array changes) -- use `useEffect` with empty deps `[]` since it reads from `getState()` directly.
  </action>
  <verify>
    Run `npm run build` -- must compile without errors.
    Run `npm run lint` -- must pass.
    Test flow: navigate into subgraph -> breadcrumb appears -> click breadcrumb segment -> jumps back -> Esc pops one level -> browser back button pops one level.
  </verify>
  <done>
    Breadcrumb rendered in App.tsx layout. Esc key pops subgraph navigation (after search close priority check). Browser back button pops via popstate handler without circular loop. Navigation fully wired end-to-end.
  </done>
</task>

</tasks>

<verification>
- `npm run build` passes with zero errors
- `npm run lint` passes clean
- Breadcrumb appears in bottom-left when navigated into a subgraph
- Breadcrumb segments are clickable and jump to correct level
- "Overview" segment returns to full graph
- Esc key pops one navigation level (if search is closed)
- Browser back button pops one navigation level via popstate
- Breadcrumb disappears when returning to overview
</verification>

<success_criteria>
1. Breadcrumb trail visible in bottom-left corner during subgraph navigation
2. Each breadcrumb segment navigable via click
3. Esc key pops one level (priority: close search > pop subgraph)
4. Browser back button pops navigation via popstate handler
5. No circular history.pushState/popstate loop
6. Build and lint pass clean
</success_criteria>

<output>
After completion, create `.planning/phases/02-interaction-polish/02-04-SUMMARY.md`
</output>
